# 视频去水印方法总结

从素材网站下载的视频大多都留有水印，使用这些视频对使用者有较大干扰，很不方便，需要运用一定的方法尽可能去掉。通过查阅资料，视频去水印有以下常见的几种方法：
    
1. 对视频空间区域进行裁剪，仅保留干净的部分，当水印logo在视频边边角角时比较管用，如优酷视频、腾讯视频以及电视台logo等。虽然这样会损失一部分内容，但大多数情况下能够保留主要部分，可以使用格式工厂、狸窝等视频编辑软件完成该操作。
2. 对水印区域进行模糊处理，这种处理方式很常见，使用者还经常在原来的水印区域加上新的水印orz...，当水印遮盖的区域较光滑时效果极好，否则也会丢失logo下的细节，可以用爱剪辑完成该操作，不过蛋疼的是它会强制加入片头和片尾。
3. 基于（成熟的）去水印算法进行处理，据我所知最好的是Google论文[On the Effectiveness of VisibleWatermarks](http://openaccess.thecvf.com/content_cvpr_2017/papers/Dekel_On_the_Effectiveness_CVPR_2017_paper.pdf)里提到的优化算法，该算法针对图片水印进行处理，当水印在多张图间完全一样时有奇效，水印去得干干净净，这里有一个[开源实现]()，好像没论文中效果好，另外，该算法速度特别慢，在训练完成后处理单张图片用时几秒到几十秒不等，对于视频处理就不能指望了，但可以考虑在稍微降低品质的条件下对该算法进行优化提速。
4. 简单粗暴的水印减除，拿到一个视频，想方设法获得水印图片，假设一个透明度，通过加水印的反向操作，获得大致无水印的结果，该方法不能除尽水印，但若不仔细看，残留的部分也不太明显。

在我遇到的情况下，主要有来自不同网站的五种水印，模糊处理代价太大，Google的算法速度太慢，实践起来难度不小，没有过多研究，如图X是水印减除前后的效果
[!img]， image1
image2， image2
image3， image3
image4， image4
image5， image5

## 水印减除方法介绍


### 原理简介
我们知道添加水印方法是
$$
J = I * \alpha + W * (1 - \alpha)
$$
其中$I$是原图、$W$是logo图，$J$分别是添加logo之后的水印图，$\alpha$是水印的透明度，$\alpha=1$时完全看不到水印，$\alpha=0$时，水印将完全覆盖原图，在没有水印的区域$\alpha=1$，因此，求解原图的公式为
$$
I = \frac{J - W * (1 - \alpha)}{\alpha}
$$
若已知$W$和$\alpha$，就能原图。

**注意：由于习惯，下文中$\alpha$将表示原图透明度(或者是logo在水印图的占比)，$\alpha==0$表示此处没有水印。**

### 从纯色背景中提取水印图$W$，手动估计$\alpha$

一般情况下透明度是一个常数，即logo的各个位置的$\alpha$相同，本文中遇到的水印图片皆为灰白色，各颜色通道的值相同（不同也OK），假设水印为白色透明的文字，很自然可以想到利用纯黑色背景的图像获得该文字水印，可以进一步假设白色文字的颜色为255，即$W=255$，$\alpha$(logo在水印图的占比)也就是$\alpha=\frac{J_{max}}{255}$，相反，如果水印强度不一致，则可以假设一个$\alpha$（可以选择该图中较大的灰度值除以255，不是最大的灰度值，因为图片和视频压缩产生噪声的缘故，见下文），$W=\frac{J_{max}}{\alpha}$，本文中的水印图W，alpha图以及消减后结果（以下简称**消减图**）如图X，
img1——alpha，W，result
img1——alpha，W，result
img1——alpha，W，result
img1——alpha，W，result
img1——alpha，W，result

水印强度不一致的Logo，有时候仅从黑色背景下提取亮色区域是不够，还需要从白色背景下提取暗色背景。

**问题：如何获取纯色背景下的？**

1. 从视频源网站找，或者下载下来挑选。(对于每个视频源，本文利用爬虫下载了数万视频，幸运的是里面都有纯黑/白背景的素材)
2. 上传包含纯黑和纯白帧的视频，通过平台自动添加水印。

### 利用中值滤波减弱边缘噪声

从上一步处理的结果来看，logo边缘处理效果不太好，跟椒盐噪声很相似，这通常是由于制作logo时的抗锯齿效果（见下文），使得logo的边缘虚化导致。为了处理这些区域，考虑使用中值滤波修复这些区域，如果直接对整个水印区域进行中值滤波，虽然可以将水印去除干净，但信息损失量很大，使原本分辨率不高的视频变得更加模糊，如图x；另一方面，如果能够定位这些区域，仅替换这些坏的区域，则能得到一个折中的效果。

水印模糊图image

定位这些区域的简单办法是将消减图和其中值滤波图像相减，取绝对值，得到**差值图**，目标区域则是这些差值较大的像素，为了减少误差，可以用多个差值图求中值或均值，取一个阈值，将较小的噪声置零，得到最终差值图如图X，利用该差值图替换消减图中的像素点，获得接近原图的处理结果，如图X，如此形成了一个不甚完美的简单解决方案。

差值图image

原图image

## 关于图片的细节

### 1、 抗锯齿

假设你要制作一个logo水印图，内容是“**Dove**”，外面包裹一个椭圆，打开windows画图板，制作该图如下，

### 2、 图像压缩编码
打开windows画图板，画一个无需抗锯齿的图像，选择矩形，填充选择纯色，颜色1（前景色）取白色RGB=(255,255,255)，颜色2（背景色）取黑色RGB=(0,0,0)，随手画一个矩形，分别另存为bmp、jpg和png图像，用软件查看图片几乎是一模一样的，但是bmp图像的大小是jpg的几十倍，甚至上百倍，怎么做到的？
如图
image

bmp图像格式不压缩
jpg图像压缩
png图像压缩
使用python的opencv和numpy工具查看像素值的详情，jpg图像和png图像除了0和255外，还有其他分量
```python
In [89]: img_bmp = cv.imread("1.bmp")

In [90]: img_jpg = cv.imread("1.jpg")

In [91]: img_png = cv.imread("1.png")

In [92]: np.bincount(img_bmp.reshape(-1),minlength=256)
Out[92]:
array([ 28512,      0,      0,      0,      0,      0,      0,      0,
            0,      0,      0,      0,      0,      0,      0,      0,
                                    ... 28行0 ...
            0,      0,      0,      0,      0,      0,      0,      0,
            0,      0,      0,      0,      0,      0,      0, 817128],
      dtype=int64)

In [93]: np.bincount(img_jpg.reshape(-1),minlength=256)
Out[93]:
array([ 27885,    570,     30,     15,      3,      3,      3,      3,
            0,      0,      0,      0,      0,      0,      0,      0,
                                    ... 28行0 ...
            0,      0,      0,      0,      0,      0,      0,      0,
            6,      6,     12,     18,     30,     81,    339, 816636],
      dtype=int64)

In [94]: np.bincount(img_png.reshape(-1),minlength=256)
Out[94]:
array([ 27885,    570,     30,     15,      3,      3,      3,      3,
            0,      0,      0,      0,      0,      0,      0,      0,
                                    ... 28行0 ...
            0,      0,      0,      0,      0,      0,      0,      0,
            6,      6,     12,     15,     30,     81,    342, 816636],
      dtype=int64)
```

### 3、 视频压缩编码
常见的mp4格式